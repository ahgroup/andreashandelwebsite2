---
title: Bayesian analysis of longitudinal multilevel data - part XX  
description: In part XX of this series, I explore a step-by-step approach to building a Stan model.
author: Andreas Handel
date: 2024-02-17
date-modified: last-modified
aliases: 
  - ../longitudinal-multilevel-bayesian-analysis-XX/
categories: 
- R
- Data Analysis
- Bayesian
- Stan
image: "featured.png"
image-alt: ""
execute:
  echo: true
engine: knitr
---



```{r, include=FALSE, cache=FALSE}
knitr::read_chunk('cmdstanr-ode-test-script.R')
```


# Overview

This tutorial is part of [the series of posts](/posts/2022-02-22-longitudinal-multilevel-bayes-1/)
showing how to fit longitudinal data using Bayesian multilevel/hierarchical/mixed-effects models. To be able to follow along, you should start with the first post, and at least skim through the posts all the way to the ODE model posts. Otherwise, the following won't make much sense üòÅ.

This tutorial shows a way I find helpful for building more complicated (at least to me) Stan models.

Here is [the Stan code for this example](stancode-ode-testing.stan) and this is [the R script that runs everything](cmdstanr-ode-test-script.R).



# Introduction

A while ago, I wrote [a series of tutorials](/posts/2022-02-22-longitudinal-multilevel-bayes-1/) that discuss fitting longitudinal data using Bayesian multilevel/hierarchical/mixed-effects models. 

I started with fairly simple models to describe the longitudinal/time-series/panel data (in my case, virus load). Initially, I used the I used the [`rethinking`](/posts/2022-02-22-longitudinal-multilevel-bayes-2/) and [`brms`](/posts/2022-02-22-longitudinal-multilevel-bayes-3/) packages to build the models.

A while later, I wanted to implement the underlying model as set of ordinary differential equations, and I wanted to do that using Stan directly. 

I worked my way up to the ODE model but re-implementing the simpler model with Stan/cmdstanr first. Even then, I had a hard time getting the ODE model to work and had to do a good bit of debugging. I found it hard to debug in Stan. So I tried to come up with a way to slowly build up my model and test if my code works. 

This post describes my approach for a way to build complicated Stan models. This is mostly a note to my future self. Maybe others will find it useful too.



# The idea

I'm trying to implement the model described [in this post](). I won't repeat it here. This post is all about how to code it up.

When I tried to implement the model to fit it, Stan just refused to do it. I didn't know what the problem was, starting at the code didn't show an obvious (to me) problem. Debugging Stan is hard, I haven't figured out a good way.

So I decided I needed to test if my Stan code was working at all. To do so, I decided to implement the generative simulation model in R, then in Stan, and compare. If the simulations I get back from Stan agree with R and make sense, then I'm at least somewhat reassured that my code might be right.

This is a detailed step-through.


# Setup

Loading packages and setting some stuff.

```{r, packages, message=FALSE, warning = FALSE}
```

```{r, setup, message=FALSE, warning = FALSE}
```


# Data

It's the same data as before.


# ODE models in R

This implements the ODE model. I'm using both ways, the 


Next, a few lines of code to explore the ODE model.

```{r, explore-model}
```

I played around with the parameter values to find some that gives me a curve that looks reasonable.



## The new statistical model

I wanted a statistical model that had the overall structure of the model structure from the previous non-ODE model examples, with the only difference that now the virus trajectory is described by an ODE model. I'll get to this in the next blog post. But I wasn't able to get that model to work and therefore had to resort to building a simpler model first, just to figure out what's going on.

For the simpler model, I used the approach from the last model in the previous post, namely a model for which the main parameters are different for each individual and don't depend on dose or each other. The initial value for the virus variable is assumed to depend on dose. 

I'm not sure what the best mathematical notation is to write down this model, here is an option. I'm showing the ODE model in its original form, without the extra $\exp()$ and $\log()$ notation. The understanding is that model will be implemented as shown in the second model above, with parameters on an exponentiated scale and variables on the log scale. This is reflected in the initial condition values.


$$
\begin{aligned}
\textrm{Outcome} \\
Y_{i,t}   \sim \mathrm{Normal}\left(V_{i,t}, \sigma\right) \\
\\
\textrm{ODE model defining V} \\
\dot U  = -\beta_i UV \\ 
\dot I  = \beta_i UV - \gamma_i I \\
\dot V  = \alpha_i I - \eta_i V \\
\\
\textrm{Starting values for ODE model} \\
\textrm{initial uninfected cells} \qquad U(0) = \log(1E8)  \\
\textrm{initial infected cells} \qquad  I(0) = 0  \\
\textrm{initial virus, to be fit}  \qquad V(0) = V_i[dose] \\
\\
\textrm{Deterministic models for main parameters} \\
\alpha_{i}   =  a_{0,i}  \\
\beta_{i}   =   b_{0,i} \\
\gamma_{i}   =   g_{0,i} \\
\eta_{i}   =   e_{0,i} \\
\end{aligned}
$$
The index $i$ represents indexation with respect to individuals. The index $dose$ indicates the 3 different dose levels. 

As mentioned before, I don't really need both $\alpha, \beta,...$ here and $a_0, b_0,...$, but I'm setting this up this way so it's similar to all previous setups and easy to extend.

To fully specify the model, we need to give all parameters distributions. As before, I'm not showing the exact prior values to prevent it being different than the code, instead I'm only indicating them here with an `X`. See the code for the exact values. 

As mentioned, I'm not yet implementing partial pooling, instead each parameter has some fixed prior distribution. As a reminder, the parameters inside the ODE are the exponentiated version of this, while the starting value for the virus load is on a log scale (so the true value is the exponentiated form, but we never use that, we fully operate on a log scale for all 3 ODE model variables).


$$
\begin{aligned}
\textrm{population-level priors} \\
\sigma  \sim \mathrm{HalfCauchy}(X,X)  \\
a_{0,i} \sim \mathrm{Normal}(X, X) \\
b_{0,i} \sim \mathrm{Normal}(X, X) \\
g_{0,i} \sim \mathrm{Normal}(X, X) \\
e_{0,i} \sim \mathrm{Normal}(X, X) \\
V_i[dose] \sim \mathrm{Normal}(X, X) \\
\end{aligned}
$$


And that's the full model for the simplified case. Now we need to implement it with Stan. 



# Model implementation

We previously used the `brms` and `rethinking` R packages to run our `Stan` models in `R`, without having to write `Stan` code. One can use these packages for ODEs, but still has to write some `Stan` code. I decided instead, for flexibility, I'm writing the full model in `Stan` and then fit it through `cmdstanr` in R.

We'll use the same data as before. We need to reshape it a bit to get it into the format that `cmdstanr` requires. To make things inside the Stan code easier, we added some additional information. Note that the model we implement here won't use all of the data. We keep it in here for the next model.


```{r, data}
```


# Stan code

Next, we need to write the Stan model code. For some of the parts, I took inspiration from [this blog post by Danielle Narravo](https://blog.djnavarro.net/posts/2023-06-10_pop-pk-models/). The code is again in a separate file, linked at the top of this post. 

The code keeps growing. I'm not going to explain it in detail, but will point out a few new parts. 

* There is now a `functions` block which defines the ODE model function. The notation is rather similar to the `deSolve` R implementation shown above. This function is called inside the `generated parameters` block and integrated using the `ode_rk45` routine that is part of Stan. 

* For the `data` part, I'm passing in values for priors for all parameters. I also now have a variable `dose_level` that is an indicator variable taking on values 1,2,3 for the 3 different dose levels, and used to index the starting value for the virus load, which we assume only differs by dose and not individual person.

* There's also a `transformed data` block that computes some indices to keep track of the first and last value of each individual in the long vector of all observations. 

* The ode integration happens inside the `generated parameters` block. We loop over every individual and run the ODE model, then save the results for each individual in the long `virus_pred` vector.


```{.stan include="stancode-ode-simple.stan"}
```


Next, we load and compile the Stan model.

```{r, make_stanmodel, message=FALSE, warning = FALSE, eval=FALSE}
```


# Model fitting settings

As before, we need to specify settings for the MCMC algorithm and starting values (the latter of which is optional but I consider good practice).

```{r, fitconditions}
```

```{r, initialconditions}
```


# Model fitting 


This runs the model. It's not actually run here to speed up generation of this Quarto file, but the code chunk is in the R script, so you can run it.

```{r, run_m1, message=FALSE, warning = FALSE, output = FALSE, eval=FALSE}
```

If you were to run it, you'll find that it takes rather long. That's a major problem with ODE model fitting in a Bayesian framework. Those models take long to run and one needs to run them for each iteration. In the future, I hope to re-implement this in `Julia`, which is a programming language that has faster ODE solvers. But I don't have a ton of Julia experience, so this will come after I fully get this example to work üòÅ.


# Model result loading

To save time, we don't run the model each time, instead we save the results and load them.

```{r, loadfits, message=FALSE, warning = FALSE}
```


# Model exploration

Get the samples.

```{r, get_samples_m1,  warning = FALSE}
```


Model diagnostics.

```{r, diagnose_m1,  warning = FALSE, message = FALSE}
```

Ok, so the sampler isn't quite happy. 

Next, we'll take a look at a summary table for the distributions of some of the model parameters. I cut it off since there are too many to show (each individual as multiple parameters with associated distributions).


```{r, summarize_m1}
```

We can't really compare with the values we used to generate the model since we are using a different model to fit the data. However, since we have a mechanistic model, and the parameters have biological meaning, we can do a reality-check, at least for some of them. For instance the inverse of the parameter $\gamma$ is the lifespan of an infected cell. If we have some knowledge of the system, we can see if our estimate agrees with that. Even without much knowledge, we would still expect an infected cell at minimum to live on average say a few hours -- otherwise it could never produce any virus -- and at most maybe days/weeks/months, depending on the pathogen we model. So if our predictions correspond to lifespans of seconds or millenia, we know something isn't right. The fact that model parameters have biological meaning is unique to mechanistic models. For phenomenological models (e.g., some type of GLM), interpretation of parameters is not as clear. Though even in those situations, one can often spot parameters that make no sense. For instance a prediction that each 1 pound increase in weight for children leads to increase in 1 meter of height is clearly nonsensical. So it's always important to look at the parameter values and contemplate if they make sense, given what we know about the real world.


Let's again look at a few plots to make sure everything looks reasonable. Here I'm showing again a trace plot and a posterior density plot. 

```{r, plot_par_m1,  warning = FALSE}
```

The pairs plot shows a strong correlation between $\beta$ and $\gamma$.


Next, we'll compare prior and posterior distributions. This can give an indication if the priors were selected well or are too broad or overly influential. To be able to show priors, we needed all that extra information in the _generated quantities_ block in the Stan code.


```{r, prep_data_m1}
```


```{r, prior_post_m1}
```

The plots show that the priors don't overly influence the results, the data dominates the posteriors (they move and get more peaked, an indication that the data controls the posterior shape).


I'm skipping the additional diagnostics with the `loo` package, the same code as in the previous examples would work. I'm also not showing the observed versus predicted plot, since we will look at the actual data and model predictions, which for this type of model is more informative.


# Model predictions

Finally, we again want to look at the actual data and the model predictions. It's exactly the same code as for the 2-parameter model.

```{r, make_predictions,  warning = FALSE, message = FALSE}
```

```{r, plot_predictions,  warning = FALSE, message = FALSE}
```

The model fits don't look that great. I'm not sure why the model isn't capturing the data better, if it needs more iterations and/or better choice of priors, or if there's something inherent about the structure of this model not being able to capture the data generated by the 2-parameter model, even though it is more flexible with its 4 parameters.



# Summary and continuation

This completes the first half of the ODE model example. I'm finally ready to implement the more detailed model I really want to look at, which [is covered in the next post](/posts/2024-02-18-longitudinal-multilevel-bayes-8/).







