{
  "hash": "9841e378f312ca545b29eb23dc5491b8",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: Bayesian analysis of longitudinal multilevel data using brms and rethinking - part 7  \ndescription: In part 7 of this series, I show how to fit a very simple ODE model using Stan.\nauthor: Andreas Handel\ndate: 2024-02-17\ndate-modified: last-modified\naliases: \n  - ../longitudinal-multilevel-bayesian-analysis-7/\ncategories: \n- R\n- Data Analysis\n- Bayesian\n- Stan\nimage: \"featured.png\"\nimage-alt: \"trajectories generated by ODE model\"\nexecute:\n  echo: false\nengine: knitr\n---\n\n\n\n\n# Overview\n\nThis tutorial continues [the series of posts](/posts/2022-02-22-longitudinal-multilevel-bayes-1/)\nshowing how to fit longitudinal data using Bayesian multilevel/hierarchical/mixed-effects models. To be able to follow along, you should start with the first post. Otherwise, the following won't make much sense üòÅ.\n\nThis tutorial starts the example where the underlying model is given by a set of ordinary differential equations (ODEs). This was originally meant to be a single post, but -- perhaps not surprisingly -- I couldn't get the model I wanted to work. To debug, I had to go slower and had to resort to first fiddling with a simpler model.\n\nI figured these intermediate steps might be useful for folks, so instead of hiding it and just showing you the final model -- which I eventually managed to get working, I decided to also write up these intermediate steps. \n\nSo this post introduces the ODE model and a simple statistical model, and then in the [next post](/longitudinal-multilevel-bayes-8/), I finally do the model I wanted to do.\n\nHere is [the Stan code for this example](stancode-ode-simple.stan) and this is [the R script that runs everything](cmdstanr-ode-simple-script.R).\n\n\n\n# Introduction\n\nA while ago, I wrote [a series of tutorials](/posts/2022-02-22-longitudinal-multilevel-bayes-1/) that discuss fitting longitudinal data using Bayesian multilevel/hierarchical/mixed-effects models.\n\nFor the first few posts in this series, I used the [`rethinking`](/posts/2022-02-22-longitudinal-multilevel-bayes-2/) and [`brms`](/posts/2022-02-22-longitudinal-multilevel-bayes-3/) packages to run `Stan` models in `R`, without having to write `Stan` code. \n\nIn those examples, I had a simple model that captured the longitudinal data (in my example, virus load) trajectory.\n\nFor a research project, I now want to implement a model that uses a set of ordinary differential equations (ODEs). I figured to understand what I'm trying to do, I should first teach myself and write it up in a tutorial. \n\nOne can use packages like `rethinking` or `brms` with ODE models, but one still has to write some `Stan` code. I decided instead, for my purpose, it is better to write the full model in `Stan` and then fit it through `cmdstanr` in R.\n\nThe prior two posts show [one of the original models](/posts/2024-02-15-longitudinal-multilevel-bayes-5/) and a [more complex model](/posts/2024-02-16-longitudinal-multilevel-bayes-6/) implemented in Stan. I assume you read those posts. In this post, I'll move on to an ODE-based model.\n\n\n\n\n# The idea\n\nThe most common types of models used to describe data are those that are non-mechanistic -- or phenomenological, like [I like to call them](https://www.nature.com/articles/s41577-019-0235-3). What's meant by that is that the model represents a convenient and suitable way to describe the data, but does not try to capture any information about the underlying mechanisms of the system and processes that led to the observed data.\n\nIn contrast, mechanistic models are -- very simplified -- representations of the assumed or known underlying processes. As such, they allow incorporation of expert knowledge, and are potentially better at providing a fuller understanding of the system - but also require such a better understanding at the start to even allow using such models. \n\nThat's all I'll say about these models, you can learn more in [this review article I wrote with colleagues](https://www.nature.com/articles/s41577-019-0235-3) or on [this website](https://andreashandel.github.io/SMIcourse/). Both of these resources are immunology-focused, but the general concepts are the same for any subject matter area.\n\nA common way of implementing mechanistic models that describe the dynamics of some system is through ordinary differential equations (ODEs). This is the approach I'll be taking here.\n\n\n# The ODE model\n\nAs a reminder, our outcome/data of interest are virus load time-series trajectories of individuals following infection.\n\nTo get an ODE model that can capture the shape of our data, I use a simple basic virus dynamics model. I won't explain this model here, if you want to learn more about these kind of models, see for instance [this short write-up](https://andreashandel.github.io/SMIcourse/A_Few_Simple_Models.html#Simple_Viral_Infection_Model) on my [Simulation Modeling for Immunologists website](https://andreashandel.github.io/SMIcourse/) or [this reference](https://www.nature.com/articles/nri700).\n\nHere are the model equations\n\n$$\n\\begin{aligned}\n\\textrm{uninfected cells:} \\qquad  \\dot U & = -\\beta_i UV \\\\ \n\\textrm{infected cells:} \\qquad  \\dot I & = \\beta_i UV - \\gamma_i I \\\\\n\\textrm{virus:} \\qquad  \\dot V & = \\alpha_i I - \\eta_i V\n\\end{aligned}\n$$\nThis model has 4 parameters, each is indexed by $i$ to indicate that it can differ between individuals. For any ODE model, one needs to not only specify the model parameters but also the starting values of each quantity. To keep things simple, below I assume that the number of uninfected cells and infected cells is known and the same for each individual, and that the virus load is given by the experimental conditions, i.e. the dose. More generally, it would be possible to let the starting values vary and estimate them from the data.\n\nWhile the model tracks the dynamics of 3 quantities, we only have data for one, namely the virus $V$. The log of the time-series obtained for $V$ by solving these ODEs is what is now assumed to be the average trajectory, namely what we formerly called $\\mu$ in the statistical model.\n\n\n\n# Mathematical shenanigans\n\nSo the model above is what I want to run, but it turns out that implementing the model in this form is not a good idea for several reasons.\n\nFirst, we have the issue with positive parameters again. The model above assumes all parameters are positive. To enforce that, we can again use the trick of exponentiating the parameters. This is what we'll do. You'll see it in the code below.\n\nSecond the values for the model variables change a lot. We start with a lot of uninfected cells (millions or more), no infected cells and a little bit of virus. The virus then grows rapidly, and so do the infected cells. The uninfected cell numbers crash. These extreme changes in variables are hard on the ODE solver. I initially tried to implement the model as written above (after enforcing parameters to be positive by exponentiating), and then in the end take the log of the virus load. That didn't work well. So I decided to just run the whole model in log units. \n\nThat means, the model I'm actually running is\n\n\n$$\n\\begin{aligned}\n\\textrm{uninfected cells:} \\qquad  \\frac{d}{dt} \\log(U) & = -\\exp(\\beta_i) \\log(U) \\log(V) \\\\ \n\\textrm{infected cells:} \\qquad  \\frac{d}{dt} \\log(I) & = \\exp(\\beta_i) \\log(U) \\log(V) - \\exp(\\gamma_i) \\log(I) \\\\\n\\textrm{virus:} \\qquad  \\frac{d}{dt} \\log(V) & = \\exp(\\alpha_i) \\log(I) - \\exp(\\eta_i) \\log(V)\n\\end{aligned}\n$$\n\n\nI want to re-iterate that this is the same model as above, just doing various transformations to make the code run.\n\n\n# ODE model exploration\n\nTo get a quick idea for the model behavior, I wrote a few lines of R code to run it.\n\n\n::: {.cell}\n\n:::\n\n\nI played around with the parameter values to find some that gives me a curve that looks reasonable.\n\n\n\n## The new statistical model\n\nI wanted a statistical model that had the overall structure of the model structure from the previous non-ODE model examples, with the only difference that now the virus trajectory is described by an ODE model. I'll get to this in the next blog post. But I wasn't able to get that model to work and therefore had to resort to building a simpler model first, just to figure out what's going on.\n\nThese are the components of this new model, now with an ODE model describing the deterministic part. I'm not sure what the best mathematical notation is, here is an option. \n\nI'm showing the ODE model in its original form, without the extra $\\exp()$ and $\\log()$ notation. The understanding is that model will be implemented as shown in the second model above, with parameters on an exponentiated scale and variables on the log scale. This is reflected in the initial condition values.\n\n\n$$\n\\begin{aligned}\n\\textrm{Outcome} \\\\\nY_{i,t}   \\sim \\mathrm{Normal}\\left(V_{i,t}, \\sigma\\right) \\\\\n\\\\\n\\textrm{ODE model defining V} \\\\\n\\dot U  = -\\beta_i UV \\\\ \n\\dot I  = \\beta_i UV - \\gamma_i I \\\\\n\\dot V  = \\alpha_i I - \\eta_i V \\\\\n\\\\\n\\textrm{Starting values for ODE model} \\\\\n\\textrm{initial uninfected cells} \\qquad U(0) = \\log(1E8)  \\\\\n\\textrm{initial infected cells} \\qquad  I(0) = 0  \\\\\n\\textrm{initial virus, to be fit}  \\qquad V(0) = V_i[dose] \\\\\n\\\\\n\\textrm{Deterministic models for main parameters} \\\\\n\\alpha_{i}   =  a_{0,i}  \\\\\n\\beta_{i}   =   b_{0,i} \\\\\n\\gamma_{i}   =   g_{0,i} \\\\\n\\eta_{i}   =   e_{0,i} \\\\\n\\end{aligned}\n$$\nThe index $i$ represents indexation with respect to individuals. The index $dose$ indicates the 3 different dose levels. \n\nThis model structure assumes that every individual has their own value for the ODE model parameters. The initial value for the virus load only differs for different dose groups. \n\nTo fully specify the model, we need to give all parameters distributions. I'm not yet implementing the partial pooling, instead each parameter has some fixed prior distribution. As a reminder, the parameters inside the ODE are the exponentiated version of this, while the starting value for the virus load is on a log scale (so the true value is the exponentiated form, but we never use that, we fully operate on a log scale for all 3 ODE model variables).\n\n\n$$\n\\begin{aligned}\n\\textrm{population-level priors} \\\\\n\\sigma  \\sim \\mathrm{Exponential}(1)  \\\\\na_{0,i} \\sim \\mathrm{Normal}(3, 1) \\\\\nb_{0,i} \\sim \\mathrm{Normal}(-1, 1) \\\\\ng_{0,i} \\sim \\mathrm{Normal}(1, 1) \\\\\ne_{0,i} \\sim \\mathrm{Normal}(1, 1) \\\\\nV_i[dose] \\sim \\mathrm{Normal}(5, 1) \\\\\n\\end{aligned}\n$$\n\n\nAnd that's the full model for the simplified case. Now we need to implement it with Stan. \n\n\n\n# Model implementation\n\nWe previously used the `brms` and `rethinking` R packages to run our `Stan` models in `R`, without having to write `Stan` code. One can use these packages for ODEs, but still has to write some `Stan` code. I decided instead, for flexibility, I'm writing the full model in `Stan` and then fit it through `cmdstanr` in R.\n\n\n\n::: {.cell}\n\n:::\n\n\nWe'll use the same data as before. We need to reshape it a bit to get it into the format that `cmdstanr` requires. To make things inside the Stan code easier, we added some additional information.\n\n\n\n::: {.cell}\n\n:::\n\n\n\n# Stan code\n\nNext, we need to write the Stan model code. For some of the parts, I took inspiration from [this blog post by Danielle Narravo](https://blog.djnavarro.net/posts/2023-06-10_pop-pk-models/). The code is again in a separate file. This loads and compiles the Stan model.\n\n\n::: {.cell}\n\n:::\n\n\nHere is the code. It keeps growing. I'm not going to explain it in detail, but will point out a few new parts. \n\n* There is now a `functions` block which defines the ODE model function. The notation is rather similar to the `deSolve` R implementation shown above. This function is called inside the `generated parameters` block and integrated using the `ode_rk45` routine that is part of Stan. \n\n* For the `data` part, I'm passing in values for priors for all parameters. I also now have a variable `dose_level` that is an indicator variable taking on values 1,2,3 for the 3 different dose levels, and used to index the starting value for the virus load, which we assume only differs by dose and not individual person.\n\n* There's also a `transformed data` block that computes some indices to keep track of the first and last value of each individual in the long vector of all observations. \n\n* The ode integration happens inside the `generated parameters` block. We loop over every individual and run the ODE model, then save the results for each individual in the long `virus_pred` vector.\n\n\n```{.stan include=\"stancode-ode-simple.stan\"}\n```\n\n# Model fitting settings\n\nAs before, we need to specify settings for the MCMC algorithm and starting values (the latter of which is optional but I consider good practice).\n\n\n::: {.cell}\n\n:::\n\n::: {.cell}\n\n:::\n\n\n\n# Model fitting \n\n\nThis runs the model. It's not actually run here to speed up generation of this Quarto file, but the code chunk is in the R script, so you can run it.\n\n\n::: {.cell}\n\n:::\n\n\nIf you were to run it, you'll find that it takes rather long. That's a major problem with ODE model fitting in a Bayesian framework. Those models take long to run and one needs to run them for each iteration. In the future, I hope to re-implement this in `Julia`, which is a programming language that has faster ODE solvers. But I don't have a ton of Julia experience, so this will come after I fully get this example to work üòÅ.\n\n\n# Model result loading\n\nTo save time, we don't run the model each time, instead we save the results and load them.\n\n\n::: {.cell}\n\n:::\n\n\n# Model exploration\n\nFirst, we look at diagnostics from the fitting routine to make sure nothing obviously wrong shows up.\n\n\n\n::: {.cell}\n\n:::\n\n\nOk, so the sampler isn't quite happy. We should sample more and more stringently, but that would take very long. So for the purpose of this investigation, and given that I'm only exploring this model as a stepping stone to the ODE model I'm really interested in, I'll leave it the way it is. If this were an actual research project, I would obviously need to improve the model performance.\n\nNext, we'll take a look at a summary table for the distributions of some of the model parameters. I cut it off since there are too many to show (each individual as multiple parameters with associated distributions).\n\n\n\n::: {.cell}\n\n:::\n\n\nWe can't really compare with the values we used to generate the model since we are using a different model to fit the data, so we shouldn't expect any parameters to be similar. Thus, I'm not focusing further on the values. Again, for a real research project, you would want to carefully evaluate the parameters (after addressing the problems with the algorithm not working well).\n\n\nLet's again look at a few plots to make sure everything looks reasonable. We'll first need to get the samples, both with and without warmups, to be able to make various figures.\n\n\n::: {.cell}\n\n:::\n\n\n\nNow we can look at a few figures. Here I'm showing again a trace plot, a posterior density plot and a pairs plot. \n\n\n::: {.cell}\n\n:::\n\n\nThe pairs plot shows a strong correlation between $\\beta$ and $\\gamma$.\n\n\nNext, we'll compare prior and posterior distributions. This can give an indication if the priors were selected well or are too broad or overly influential. To be able to show priors, we needed all that extra information in the _generated quantities_ block in the Stan code.\n\n\n\n::: {.cell}\n\n:::\n\n::: {.cell}\n\n:::\n\n\nThe plots show that the priors don't overly influence the results, the data dominates the posteriors (they move and get more peaked, an indication that the data controls the posterior shape).\n\n\nI'm skipping the additional diagnostics with the `loo` package, the same code as in the previous examples would work. I'm also not showing the observed versus predicted plot, since we will look at the actual data and model predictions, which for this type of model is more informative.\n\n\n# Model predictions\n\nFinally, we again want to look at the actual data and the model predictions. It's exactly the same code as for the 2-parameter model.\n\n\n::: {.cell}\n\n:::\n\n::: {.cell}\n\n:::\n\n\nThe model fits don't look that great. I'm not sure why the model isn't capturing the data better, if it needs more iterations and/or better choice of priors, or if there's something inherent about the structure of this model not being able to capture the data generated by the 2-parameter model, even though it is more flexible with its 4 parameters.\n\n\n\n# Summary and continuation\n\nThis completes the first half of the ODE model example. I'm finally ready to implement the more detailed model I really want to look at, which [is covered in the next post](/posts/2024-02-18-longitudinal-multilevel-bayes-8/).\n\n\n\n\n\n\n\n",
    "supporting": [
      "index_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}